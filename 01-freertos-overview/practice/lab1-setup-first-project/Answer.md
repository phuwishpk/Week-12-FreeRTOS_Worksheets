
## Checklist การทำงาน

- [ ] ตรวจสอบ ESP-IDF environment สำเร็จ
- [ ] สร้างโปรเจกต์ใหม่ได้
- [ ] เข้าใจโครงสร้างโปรเจกต์
- [ ] Build โปรเจกต์สำเร็จ
- [ ] แก้ไขโค้ดและ build ใหม่ได้
- [ ] เข้าใจไฟล์ CMakeLists.txt
- [ ] ทำแบบฝึกหัดครบ

## คำถามทบทวหน

1.  **ระบบไหนมีเวลาตอบสนองดีกว่า? เพราะอะไร?**
    * **Preemptive Multitasking** มีเวลาตอบสนองดีกว่า โดยเฉพาะสำหรับงานที่มีลำดับความสำคัญ (priority) สูง. เพราะระบบปฏิบัติการ (RTOS) สามารถ **บังคับ** ให้ Task ที่มี priority ต่ำกว่าหยุดทำงานชั่วคราว เพื่อให้ Task ที่มี priority สูงกว่าได้ทำงานทันที. ส่วน Cooperative Multitasking ต้องรอให้ Task ที่ทำงานอยู่ **สละ CPU** เอง (`yield()`) ซึ่งอาจทำให้ Task สำคัญรอการตอบสนองนานหาก Task ที่ทำงานอยู่ใช้เวลานานหรือไม่ยอมสละ CPU.

2.  **ข้อดีของ Cooperative Multitasking คืออะไร?**
    * **ใช้ทรัพยากรน้อย**: ต้องการหน่วยความจำ (RAM) และพลังประมวลผล (CPU) น้อยกว่า Preemptive เพราะมีความซับซ้อนในการจัดการน้อยกว่า.
    * **Context Switching Overhead ต่ำ**: การสลับ Task เกิดขึ้นเมื่อ Task สละ CPU เอง ทำให้เกิด overhead น้อยกว่า.
    * **ง่ายต่อการพัฒนาและ Debug**: โครงสร้างโปรแกรมมักจะง่ายกว่า.
    * **เหมาะสำหรับระบบทรัพยากรจำกัด**.

3.  **ข้อเสียของ Cooperative Multitasking คืออะไร?**
    * **การตอบสนองไม่แน่นอน**: Task สำคัญอาจต้องรอนาน หาก Task ที่ทำงานอยู่ไม่ยอมสละ CPU.
    * **Task หนึ่งสามารถทำให้ระบบหยุดทำงานได้**: หาก Task ใดมีข้อผิดพลาดหรือไม่ยอมสละ CPU จะทำให้ Task อื่นๆ ไม่ได้ทำงานเลย.
    * **ไม่เหมาะกับ Real-time systems ที่เข้มงวด**: ไม่สามารถรับประกันเวลาตอบสนองที่แน่นอนได้.
    * **ต้องอาศัยความร่วมมือ**: ประสิทธิภาพขึ้นอยู่กับการเขียนโค้ดของทุก Task ให้สละ CPU อย่างเหมาะสม.

4.  **ในสถานการณ์ใดที่ Cooperative จะดีกว่า Preemptive?**
    * ในระบบที่มี **ทรัพยากรจำกัดมาก** (RAM น้อย, CPU ช้า) ที่ไม่สามารถรองรับ overhead ของ Preemptive RTOS ได้.
    * ในระบบที่ไม่ต้องการ **การตอบสนองแบบ Real-time ที่เข้มงวด** หรือ Task ทำงานสั้นๆ และสละ CPU สม่ำเสมอ.
    * เมื่อต้องการ **ความเรียบง่าย** ในการพัฒนาและ Debug.

5.  **เหตุใด Preemptive จึงเหมาะสำหรับ Real-time systems?**
    * **รับประกันเวลาตอบสนอง (Deterministic Response Time)**: ช่วยให้ Task priority สูงสุดที่พร้อมทำงาน ได้ทำงานทันทีโดยการขัดจังหวะ (preempt) Task priority ต่ำกว่า ทำให้คาดการณ์เวลาตอบสนองได้.
    * **จัดการ Priority ได้**: Task สำคัญกว่าจะได้ทำงานก่อนเสมอ.
    * **ป้องกันการครอบครอง CPU โดย Task เดียว**: RTOS ควบคุมการสลับ Task.
    * **เหมาะกับงานที่ซับซ้อน**: จัดการ Task หลากหลายที่มีความต้องการด้านเวลาต่างกันได้.