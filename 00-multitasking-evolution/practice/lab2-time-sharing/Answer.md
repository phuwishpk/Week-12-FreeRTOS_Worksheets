## คำถามสำหรับวิเคราะห์
1.  **Time slice ขนาดไหนให้ประสิทธิภาพดีที่สุด? เพราะอะไร?**
    * Time slice ขนาดกลางถึงยาว (เช่น 50ms หรือ 100ms) มักจะให้ **ประสิทธิภาพ CPU Utilization สูงสุด**. เพราะว่า **Context Switching Overhead** (เวลาที่สูญเสียไปกับการสลับ Task) จะมีสัดส่วนน้อยลงเมื่อเทียบกับเวลาที่ Task ได้ทำงานจริง. Time slice ที่สั้นมากๆ จะทำให้เกิดการสลับ Task บ่อยเกินไป ทำให้เสียเวลาไปกับ overhead มาก.

2.  **ปัญหาอะไรที่เกิดขึ้นเมื่อ time slice สั้นเกินไป?**
    * **Context Switching Overhead สูง**: ระบบจะใช้เวลาส่วนใหญ่ไปกับการสลับ Task แทนที่จะทำงานจริง ทำให้ CPU Utilization ลดลง.
    * **ประสิทธิภาพโดยรวมลดลง**: ถึงแม้ Task จะสลับกันบ่อย ดูเหมือนตอบสนองเร็ว แต่เวลาที่ใช้ทำงานจริงอาจน้อยลง.

3.  **ปัญหาอะไรที่เกิดขึ้นเมื่อ time slice ยาวเกินไป?**
    * **การตอบสนองช้าลง**: Task อื่นๆ ที่พร้อมทำงานต้องรอนานขึ้นกว่าจะได้ CPU ทำให้ระบบดูเหมือนไม่ตอบสนอง หรือตอบสนองช้าต่อเหตุการณ์.
    * **ความยุติธรรมลดลง**: Task ที่ได้ CPU ไป อาจทำงานนานเกินไป ทำให้ Task อื่นรอคอยนาน.

4.  **Context switching overhead คิดเป็นกี่เปอร์เซ็นต์ของเวลาทั้งหมด?**
    * จากผลการทดลองที่คาดหวังใน Lab 2:
        * Time slice 10ms: Overhead ประมาณ **25-30%**.
        * Time slice 50ms: Overhead ประมาณ **10-15%**.
        * Time slice 100ms: Overhead ประมาณ **5-10%**.
    * จะเห็นว่า Overhead ลดลงเมื่อ Time slice ยาวขึ้น.

5.  **งานไหนที่ได้รับผลกระทบมากที่สุดจากการ time-sharing?**
    * **งานที่ใช้เวลาประมวลผลนาน (Heavy computation task)** เช่น `simulate_processing_task`. งานประเภทนี้มักจะถูกขัดจังหวะก่อนที่จะทำงานเสร็จ ทำให้ต้องใช้หลาย time slice กว่าจะเสร็จสมบูรณ์ และการสลับ Task บ่อยๆ ก็เพิ่ม overhead เข้าไปอีก.
    * **งานที่ต้องการการตอบสนองเร็ว**: แม้ time-sharing จะช่วยให้ Task อื่นได้ทำงานบ้าง แต่ถ้ามีงานคำนวณหนักๆ คั่นอยู่ งานที่ต้องการตอบสนองเร็วก็อาจจะยังล่าช้าอยู่ดีเมื่อเทียบกับระบบ Preemptive.